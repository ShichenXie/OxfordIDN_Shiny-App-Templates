{
    "collab_server" : "",
    "contents" : "## =============================== License ========================================\n## ================================================================================\n## This work is distributed under the MIT license, included in the parent directory\n## Copyright Owner: University of Oxford\n## Date of Authorship: 2016\n## Author: Martin John Hadley (orcid.org/0000-0002-3039-6849)\n## Data Source: local file\n## ================================================================================\n\n## ==== Packages to load for server\n\nlibrary(shiny) # Some advanced functionality depends on the shiny package being loaded server-side, including plot.ly\nlibrary(scales)\nlibrary(plyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(DT)\n\nlibrary(maps)\nlibrary(mapproj)\nlibrary(leaflet)\nlibrary(rgdal)\nlibrary(GISTools)\nlibrary(sp)\n\n## ==== Global Variables (server-side)\n\n## ==== Tab selection variables (these are required to support anchor links, see within shinyServer)\nurl1 <- url2 <- \"\"\n\n## ==== shinyServer\n\nshinyServer(function(input, output, session) {\n  \n  ## =========================== Import Data  =====================================\n  ## ==============================================================================\n  ## Load data points, FIPS codes and shapefiles\n  dated_date_points <-\n    read.csv(\"data/dated_data_points.csv\", stringsAsFactors = F)\n  dated_date_points$Date <- as.Date(dated_date_points$Date)\n  \n  fips_codes <-\n    read.csv(\"data/US-FIPS-Codes.csv\", stringsAsFactors = F)\n  contiguous_fips_codes <-\n    fips_codes[fips_codes$Contiguous.United.States. == \"Y\", ]\n  \n  us_congressional_districts_shapefiles <-\n    readOGR(dsn = \"data/shapefiles/\",\n            layer = \"contiguous_congressional_districts\",\n            verbose = F)\n  \n  us_states_shapefiles <-\n    readOGR(dsn = \"data/shapefiles/\",\n            layer = \"contiguous_states\",\n            verbose = F)\n  \n  ## Add State_Names to shapefiles\n  contiguous_fips_codes <- fips_codes[fips_codes$Contiguous.United.States. == \"Y\",]\n  us_congressional_districts_shapefiles$State_Name <- mapvalues(us_congressional_districts_shapefiles$STATEFP, \n                                                   from = contiguous_fips_codes$STATE, \n                                                   to = contiguous_fips_codes$STATE_NAME)\n  \n  ## =========================== UI Elements ======================================\n  ## ==============================================================================\n  \n  output$time_period_of_interest_UI <- renderUI({\n    if (is.null(input$show_timeslider)) {\n      return()\n    }\n    \n    dates <- dated_date_points$Date\n    \n    if (input$show_timeslider == TRUE) {\n      sliderInput(\n        \"time_period_of_interest\",\n        \"Time period of interest:\",\n        min = min(dates),\n        max = max(dates),\n        step = 1,\n        value = c(min(dates), max(dates)),\n        width = \"800px\",\n        timeFormat = \"%F\"\n      )\n    }\n    \n  })\n  \n  ## ======== Filter by Dates and Calculate Shapefile Tallies =====================\n  ## ==============================================================================\n  \n  data_points_between_dates <-\n    function(start.year = NA,\n             end.year = NA,\n             data = NA) {\n      data_for_analysis <- data\n      if (input$show_timeslider == TRUE) {\n        data_for_analysis <-\n          data_for_analysis[!is.na(data_for_analysis$Date),]\n        \n        data_for_analysis$Date <- as.Date(data_for_analysis$Date)\n        data_for_analysis <- subset(data_for_analysis,\n                                    Date >= start.year &\n                                      Date <= end.year)\n        data_for_analysis\n        \n      } else\n        data_for_analysis\n    }\n  \n  dated_date_points_SPDF <- reactive({\n    data_for_analysis <-\n      data_points_between_dates(\n        start.year = input$time_period_of_interest[1],\n        end.year = input$time_period_of_interest[2],\n        data = dated_date_points\n      )\n    \n    SpatialPointsDataFrame(\n      coords = data_for_analysis[, c(\"Longitude\", \"Latitude\")],\n      data = data_for_analysis,\n      proj4string = us_congressional_districts_shapefiles@proj4string\n    )\n  })\n  \n  shapefile_with_tallies <- reactive({\n    dated_date_points_SPDF <- dated_date_points_SPDF()\n    us_congressional_districts_shapefiles <-\n      us_congressional_districts_shapefiles\n    \n    shapefile_counts <-\n      poly.counts(pts = dated_date_points_SPDF, polys = us_congressional_districts_shapefiles)\n    shapefile_counts_df <- data.frame(shapefile_counts)\n    \n    ## Insert counts into the shapefiles\n    us_congressional_districts_shapefiles@data$Count.of.locations <-\n      shapefile_counts_df$shapefile_counts\n    \n    # Return for use:\n    us_congressional_districts_shapefiles\n  })\n  \n  ## =========================== Generate Choropleth ==============================\n  ## ==============================================================================\n  ## Generate pretty breaks\n  \n  pretty_bins <-\n    reactive({\n      pretty(shapefile_with_tallies()$Count.of.locations)\n    })\n  ## color.brewer palette\n  \n  \n  output$leaflet_choropleth <- renderLeaflet({\n    if (is.null(input$time_period_of_interest)) {\n      return()\n    }\n    \n    if (is.null(input$pretty_legend_scale)) {\n      return()\n    }\n    \n    shapefile_with_tallies <- shapefile_with_tallies()\n    pretty_bins <- pretty_bins()\n    \n    if (input$pretty_legend_scale) {\n      palette <- colorBin(\n        brewer.pal(length(pretty_bins) - 1, \"YlGnBu\"),\n        bins = pretty_bins,\n        pretty = FALSE,\n        # na.color = \"#cccccc\",\n        alpha = TRUE\n      )\n      \n      colors_vector <- brewer.pal(length(pretty_bins) - 1, \"YlGnBu\")\n      labels_vector <- {\n        labels_vector <- as.character()\n        for (i in 1:{\n          length(pretty_bins) - 1\n        }) {\n          labels_vector <-\n            append(labels_vector, paste0(pretty_bins[i], \" to \", pretty_bins[i + 1]))\n        }\n        labels_vector\n      }\n    } else {\n      palette <- colorBin(\n        c(\"#cccccc\", brewer.pal(5, \"YlGnBu\")),\n        bins = c(0, 1, 5, 10, 20, 50, 350),\n        pretty = FALSE,\n        # na.color = \"#cccccc\",\n        alpha = TRUE\n      )\n      colors_vector <- c(\"#cccccc\",brewer.pal(5, \"YlGnBu\"))\n      labels_vector <- c(\"0\",\"1-5\",\"5-10\",\"10-20\",\"20-50\",\"50-350\")\n    }\n    \n    \n    region_labeller <-\n      function(state_name = NA,\n               number_of_points = NA) {\n        paste0(\"<p>\", state_name, \"</p>\",\n               \"<p>\", number_of_points, \"</p>\")\n      }\n    \n    \n    map <- leaflet(data = shapefile_with_tallies) %>% addTiles()\n    map <- map %>% addPolygons(\n      stroke = TRUE,\n      color = \"#000000\",\n      smoothFactor = 0.2,\n      fillOpacity = 0.8,\n      fillColor = ~ palette(Count.of.locations),\n      weight = 1,\n      popup = ~ region_labeller(state_name = State_Name, number_of_points = Count.of.locations)\n    )\n    map %>% addPolygons(\n      data = us_states_shapefiles,\n      stroke = TRUE,\n      color = \"#000000\",\n      smoothFactor = 0.2,\n      weight = 1,\n      fill = FALSE\n    ) %>% addLegend(\n      position = 'topleft',\n      ## choose bottomleft, bottomright, topleft or topright\n      colors = colors_vector,\n      ## Generate labels from pretty_bins\n      labels = labels_vector,\n      ## legend labels (only min and max)\n      opacity = 0.6,\n      ##transparency again\n      title = \"relative<br>amount\"\n    )\n    \n    \n  })\n\n  \n})",
    "created" : 1465477686907.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3054773696",
    "id" : "C0059BA0",
    "lastKnownWriteTime" : 1465488504,
    "last_content_update" : 1465488504332,
    "path" : "~/Github/Live-Data_Scripts-and-Templates/Shiny-Templates/Self-Contained-Apps/Leaflet-map-with-timeline/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
